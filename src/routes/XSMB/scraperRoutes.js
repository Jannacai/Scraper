const express = require('express');
const { scrapeXSMB } = require('../../../scraper');
const { scrapeXSMT } = require('../../../scraperMT');
const { scrapeXSMN } = require('../../../scraperMN');
const { testScraper, getSchedulerStatus, XSMB_CONFIG, XSMT_CONFIG, XSMN_CONFIG } = require('../../services/scraperScheduler');
const router = express.Router();

console.log('scrapeXSMB:', scrapeXSMB); // Debug require
console.log('scrapeXSMT:', scrapeXSMT); // Debug require
console.log('scrapeXSMN:', scrapeXSMN); // Debug require

// Endpoint ƒë·ªÉ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu theo ng√†y (h·ªó tr·ª£ c·∫£ XSMB v√† XSMT)
router.post('/scrape', async (req, res) => {
    try {
        console.log('Received POST /api/scraper/scrape:', req.body); // Debug request
        if (!req.body) {
            return res.status(400).json({ message: 'Request body is missing or invalid' });
        }
        const { date, station, type = 'xsmb', provinces } = req.body;
        if (!date || !station) {
            return res.status(400).json({ message: 'Thi·∫øu date ho·∫∑c station' });
        }

        console.log(`B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu cho ng√†y ${date}, ƒë√†i ${station}, lo·∫°i ${type}`);

        // Ch·ªçn scraper function d·ª±a tr√™n type
        if (type === 'xsmt') {
            scrapeXSMT(date, station); // Ch·∫°y b·∫•t ƒë·ªìng b·ªô
        } else if (type === 'xsmn') {
            if (!provinces || !Array.isArray(provinces) || provinces.length === 0) {
                return res.status(400).json({ message: 'XSMN c·∫ßn danh s√°ch t·ªânh' });
            }
            await scrapeXSMN(date, station, provinces); // Ch·∫°y ƒë·ªìng b·ªô cho XSMN
        } else {
            scrapeXSMB(date, station); // Ch·∫°y b·∫•t ƒë·ªìng b·ªô
        }

        res.status(200).json({
            message: `ƒê√£ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu cho ng√†y ${date}, ƒë√†i ${station}, lo·∫°i ${type.toUpperCase()}`
        });
    } catch (error) {
        console.error('L·ªói khi k√≠ch ho·∫°t scraper:', error.message);
        res.status(500).json({ message: 'L·ªói khi k√≠ch ho·∫°t scraper', error: error.message });
    }
});

// Endpoint ƒë·ªÉ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu XSMB (backward compatibility)
router.post('/scrapeMB', async (req, res) => {
    try {
        console.log('Received POST /api/scraper/scrapeMB:', req.body);
        if (!req.body) {
            return res.status(400).json({ message: 'Request body is missing or invalid' });
        }
        const { date, station } = req.body;
        if (!date || !station) {
            return res.status(400).json({ message: 'Thi·∫øu date ho·∫∑c station' });
        }
        console.log(`B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu XSMB cho ng√†y ${date}, ƒë√†i ${station}`);
        scrapeXSMB(date, station);
        res.status(200).json({ message: `ƒê√£ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu XSMB cho ng√†y ${date}, ƒë√†i ${station}` });
    } catch (error) {
        console.error('L·ªói khi k√≠ch ho·∫°t scraper XSMB:', error.message);
        res.status(500).json({ message: 'L·ªói khi k√≠ch ho·∫°t scraper XSMB', error: error.message });
    }
});

// Endpoint ƒë·ªÉ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu XSMT (backward compatibility)
router.post('/scrapeMT', async (req, res) => {
    try {
        console.log('Received POST /api/scraper/scrapeMT:', req.body);
        if (!req.body) {
            return res.status(400).json({ message: 'Request body is missing or invalid' });
        }
        const { date, station } = req.body;
        if (!date || !station) {
            return res.status(400).json({ message: 'Thi·∫øu date ho·∫∑c station' });
        }
        console.log(`B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu XSMT cho ng√†y ${date}, ƒë√†i ${station}`);
        scrapeXSMT(date, station);
        res.status(200).json({ message: `ƒê√£ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu XSMT cho ng√†y ${date}, ƒë√†i ${station}` });
    } catch (error) {
        console.error('L·ªói khi k√≠ch ho·∫°t scraper XSMT:', error.message);
        res.status(500).json({ message: 'L·ªói khi k√≠ch ho·∫°t scraper XSMT', error: error.message });
    }
});

// Endpoint ƒë·ªÉ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu XSMN (backward compatibility)
router.post('/scrapeMN', async (req, res) => {
    try {
        console.log('Received POST /api/scraper/scrapeMN:', req.body);
        if (!req.body) {
            return res.status(400).json({ message: 'Request body is missing or invalid' });
        }
        const { date, station, provinces } = req.body;
        if (!date || !station) {
            return res.status(400).json({ message: 'Thi·∫øu date ho·∫∑c station' });
        }
        if (!provinces || !Array.isArray(provinces) || provinces.length === 0) {
            return res.status(400).json({ message: 'Thi·∫øu danh s√°ch t·ªânh ho·∫∑c danh s√°ch t·ªânh kh√¥ng h·ª£p l·ªá' });
        }

        console.log(`B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu XSMN cho ng√†y ${date}, ƒë√†i ${station}, t·ªânh: ${provinces.map(p => p.tentinh).join(', ')}`);
        await scrapeXSMN(date, station, provinces);
        res.status(200).json({ message: `ƒê√£ k√≠ch ho·∫°t c√†o d·ªØ li·ªáu XSMN cho ng√†y ${date}, ƒë√†i ${station}` });
    } catch (error) {
        console.error('L·ªói khi k√≠ch ho·∫°t scraper XSMN:', error.message);
        res.status(500).json({ message: 'L·ªói khi k√≠ch ho·∫°t scraper XSMN', error: error.message });
    }
});

// Endpoint ƒë·ªÉ ki·ªÉm tra tr·∫°ng th√°i scraper
router.get('/status', (req, res) => {
    const status = getSchedulerStatus();
    res.status(200).json({
        message: 'Scraper API is running',
        schedulers: {
            xsmb: {
                status: 'active',
                schedule: XSMB_CONFIG.schedule,
                nextRun: status.xsmb.nextRun ? status.xsmb.nextRun.toISOString() : null,
                timezone: 'Asia/Ho_Chi_Minh',
                isRunning: status.xsmb.isRunning,
                lastRun: status.xsmb.lastRun ? status.xsmb.lastRun.toISOString() : null,
                totalRuns: status.xsmb.totalRuns,
                totalErrors: status.xsmb.totalErrors
            },
            xsmt: {
                status: 'active',
                schedule: XSMT_CONFIG.schedule,
                nextRun: status.xsmt.nextRun ? status.xsmt.nextRun.toISOString() : null,
                timezone: 'Asia/Ho_Chi_Minh',
                isRunning: status.xsmt.isRunning,
                lastRun: status.xsmt.lastRun ? status.xsmt.lastRun.toISOString() : null,
                totalRuns: status.xsmt.totalRuns,
                totalErrors: status.xsmt.totalErrors
            },
            xsmn: {
                status: 'active',
                schedule: XSMN_CONFIG.schedule,
                nextRun: status.xsmn.nextRun ? status.xsmn.nextRun.toISOString() : null,
                timezone: 'Asia/Ho_Chi_Minh',
                isRunning: status.xsmn.isRunning,
                lastRun: status.xsmn.lastRun ? status.xsmn.lastRun.toISOString() : null,
                totalRuns: status.xsmn.totalRuns,
                totalErrors: status.xsmn.totalErrors
            }
        }
    });
});

// Endpoint ƒë·ªÉ test scraper ngay l·∫≠p t·ª©c
router.post('/test', async (req, res) => {
    try {
        const { type = 'xsmb' } = req.body;
        console.log(`üß™ Test scraper ƒë∆∞·ª£c k√≠ch ho·∫°t th·ªß c√¥ng cho ${type.toUpperCase()}`);
        const success = await testScraper(type);

        if (success) {
            res.status(200).json({
                message: `Test scraper ${type.toUpperCase()} th√†nh c√¥ng`,
                timestamp: new Date().toISOString()
            });
        } else {
            res.status(500).json({
                message: `Test scraper ${type.toUpperCase()} th·∫•t b·∫°i`,
                timestamp: new Date().toISOString()
            });
        }
    } catch (error) {
        console.error('‚ùå L·ªói test scraper:', error);
        res.status(500).json({
            message: 'L·ªói khi test scraper',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// Endpoint ƒë·ªÉ xem c·∫•u h√¨nh scheduler
router.get('/config', (req, res) => {
    const status = getSchedulerStatus();
    res.status(200).json({
        schedulers: {
            xsmb: {
                config: XSMB_CONFIG,
                status: {
                    isRunning: status.xsmb.isRunning,
                    lastRun: status.xsmb.lastRun ? status.xsmb.lastRun.toISOString() : null,
                    nextRun: status.xsmb.nextRun ? status.xsmb.nextRun.toISOString() : null,
                    totalRuns: status.xsmb.totalRuns,
                    totalErrors: status.xsmb.totalErrors
                },
                description: {
                    schedule: 'Ch·∫°y l√∫c 18h14 m·ªói ng√†y',
                    duration: '20 ph√∫t (t·ª´ 18h14 ƒë·∫øn 18h34)',
                    retryAttempts: '3 l·∫ßn th·ª≠ n·∫øu th·∫•t b·∫°i',
                    retryDelay: '5 gi√¢y gi·ªØa c√°c l·∫ßn th·ª≠'
                }
            },
            xsmt: {
                config: XSMT_CONFIG,
                status: {
                    isRunning: status.xsmt.isRunning,
                    lastRun: status.xsmt.lastRun ? status.xsmt.lastRun.toISOString() : null,
                    nextRun: status.xsmt.nextRun ? status.xsmt.nextRun.toISOString() : null,
                    totalRuns: status.xsmt.totalRuns,
                    totalErrors: status.xsmt.totalErrors
                },
                description: {
                    schedule: 'Ch·∫°y l√∫c 17h14 m·ªói ng√†y',
                    duration: '20 ph√∫t (t·ª´ 17h14 ƒë·∫øn 17h34)',
                    retryAttempts: '3 l·∫ßn th·ª≠ n·∫øu th·∫•t b·∫°i',
                    retryDelay: '5 gi√¢y gi·ªØa c√°c l·∫ßn th·ª≠'
                }
            },
            xsmn: {
                config: XSMN_CONFIG,
                status: {
                    isRunning: status.xsmn.isRunning,
                    lastRun: status.xsmn.lastRun ? status.xsmn.lastRun.toISOString() : null,
                    nextRun: status.xsmn.nextRun ? status.xsmn.nextRun.toISOString() : null,
                    totalRuns: status.xsmn.totalRuns,
                    totalErrors: status.xsmn.totalErrors
                },
                description: {
                    schedule: 'Ch·∫°y l√∫c 16h12 m·ªói ng√†y',
                    duration: '30 ph√∫t (t·ª´ 16h12 ƒë·∫øn 16h42)',
                    retryAttempts: '3 l·∫ßn th·ª≠ n·∫øu th·∫•t b·∫°i',
                    retryDelay: '5 gi√¢y gi·ªØa c√°c l·∫ßn th·ª≠',
                    automation: 'T·ª± ƒë·ªông h√≥a ho√†n to√†n'
                }
            }
        }
    });
});

// Endpoint ƒë·ªÉ xem logs chi ti·∫øt
router.get('/logs', (req, res) => {
    const status = getSchedulerStatus();
    res.status(200).json({
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        schedulers: status,
        environment: {
            nodeEnv: process.env.NODE_ENV,
            timezone: process.env.TIMEZONE || 'Asia/Ho_Chi_Minh',
            port: process.env.PORT || 4000
        }
    });
});

module.exports = router;