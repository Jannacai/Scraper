const cron = require('node-cron');
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');
const { scrapeXSMB } = require('../../scraper');
const { scrapeXSMT } = require('../../scraperMT');
const { scrapeXSMN } = require('../../scraperMN');
require('dotenv').config();

// Helper function ƒë·ªÉ l·∫•y th·ªùi gian Vi·ªát Nam
const getVietnamTime = () => {
    const now = new Date();
    return new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Ho_Chi_Minh' }));
};

// Helper function ƒë·ªÉ format ng√†y
const formatDate = (date) => {
    return date.toLocaleDateString('vi-VN', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
    }).replace(/\//g, '-');
};

// C·∫•u h√¨nh scheduler cho XSMB t·ª´ environment variables
const XSMB_CONFIG = {
    schedule: process.env.SCRAPE_SCHEDULE || '14 18 * * *', // Ch·∫°y l√∫c 18h14 m·ªói ng√†y
    station: 'xsmb',
    duration: 20 * 60 * 1000, // 20 ph√∫t (t·ª´ 18h14 ƒë·∫øn 18h34)
    retryAttempts: parseInt(process.env.SCRAPER_RETRY_ATTEMPTS) || 3,
    retryDelay: parseInt(process.env.SCRAPER_RETRY_DELAY) || 5000 // 5 gi√¢y
};

// C·∫•u h√¨nh scheduler cho XSMT t·ª´ environment variables
const XSMT_CONFIG = {
    schedule: process.env.SCRAPE_SCHEDULE_MT || '14 17 * * *', // Ch·∫°y l√∫c 17h14 m·ªói ng√†y
    station: 'xsmt',
    duration: 20 * 60 * 1000, // 20 ph√∫t (t·ª´ 17h14 ƒë·∫øn 17h34)
    retryAttempts: parseInt(process.env.SCRAPER_RETRY_ATTEMPTS) || 3,
    retryDelay: parseInt(process.env.SCRAPER_RETRY_DELAY) || 5000 // 5 gi√¢y
};

// C·∫•u h√¨nh scheduler cho XSMN t·ª´ environment variables
const XSMN_CONFIG = {
    schedule: process.env.SCRAPE_SCHEDULE_MN || '24 16 * * *', // Ch·∫°y l√∫c 16h12 m·ªói ng√†y
    station: 'xsmn',
    duration: 30 * 60 * 1000, // 30 ph√∫t (t·ª´ 16h12 ƒë·∫øn 16h42)
    retryAttempts: parseInt(process.env.SCRAPER_RETRY_ATTEMPTS) || 3,
    retryDelay: parseInt(process.env.SCRAPER_RETRY_DELAY) || 5000 // 5 gi√¢y
};

// Global state ƒë·ªÉ track scheduler
let schedulerState = {
    xsmb: {
        isRunning: false,
        lastRun: null,
        nextRun: null,
        totalRuns: 0,
        totalErrors: 0
    },
    xsmt: {
        isRunning: false,
        lastRun: null,
        nextRun: null,
        totalRuns: 0,
        totalErrors: 0
    },
    xsmn: {
        isRunning: false,
        lastRun: null,
        nextRun: null,
        totalRuns: 0,
        totalErrors: 0
    }
};

// Worker thread ƒë·ªÉ ch·∫°y scraper
const runScraperInWorker = (date, station, maxRetries, scraperType) => {
    return new Promise((resolve, reject) => {
        const path = require('path');
        const workerPath = path.resolve(__dirname, '../workers/scraperWorker.js');

        const worker = new Worker(workerPath);

        worker.on('message', (result) => {
            resolve(result);
        });

        worker.on('error', (error) => {
            reject(error);
        });

        // G·ª≠i data ƒë·∫øn worker
        worker.postMessage({
            date,
            station,
            maxRetries,
            scraperType
        });

        // Timeout sau 10 ph√∫t
        setTimeout(() => {
            worker.terminate();
            reject(new Error('Worker timeout'));
        }, 10 * 60 * 1000);
    });
};

// H√†m c√†o d·ªØ li·ªáu v·ªõi retry logic (s·ª≠ d·ª•ng worker thread)
const scrapeWithRetry = async (date, station, maxRetries = 3, scraperType = 'xsmb') => {
    try {
        console.log(`üîÑ B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu ${scraperType.toUpperCase()} cho ng√†y ${date} (s·ª≠ d·ª•ng worker thread)`);

        const result = await runScraperInWorker(date, station, maxRetries, scraperType);

        if (result.success) {
            console.log(`‚úÖ C√†o d·ªØ li·ªáu ${scraperType.toUpperCase()} th√†nh c√¥ng cho ng√†y ${date}`);
            schedulerState[scraperType].totalRuns++;
            return true;
        } else {
            console.error(`‚ùå C√†o d·ªØ li·ªáu ${scraperType.toUpperCase()} th·∫•t b·∫°i cho ng√†y ${date}`);
            schedulerState[scraperType].totalErrors++;
            return false;
        }
    } catch (error) {
        console.error(`üí• L·ªói worker thread cho ${scraperType.toUpperCase()}:`, error.message);
        schedulerState[scraperType].totalErrors++;
        return false;
    }
};

// H√†m ch√≠nh ƒë·ªÉ kh·ªüi ƒë·ªông scheduler cho XSMB
const startScraperScheduler = () => {
    console.log('üöÄ Kh·ªüi ƒë·ªông XSMB Scraper Scheduler (v·ªõi worker threads)...');
    console.log(`üìÖ L·ªãch ch·∫°y: ${XSMB_CONFIG.schedule} (18h14 m·ªói ng√†y)`);
    console.log(`‚è±Ô∏è Th·ªùi gian ch·∫°y: ${XSMB_CONFIG.duration / 60000} ph√∫t`);
    console.log(`üîÑ Retry attempts: ${XSMB_CONFIG.retryAttempts}`);
    console.log(`‚è≥ Retry delay: ${XSMB_CONFIG.retryDelay / 1000} gi√¢y`);
    console.log(`üåç Timezone: ${process.env.TIMEZONE || 'Asia/Ho_Chi_Minh'}`);
    console.log(`‚ö° Worker threads: Enabled`);

    // T√≠nh to√°n th·ªùi gian ch·∫°y ti·∫øp theo
    const now = getVietnamTime();
    const nextRun = new Date(now);
    nextRun.setHours(18, 14, 0, 0);

    if (now > nextRun) {
        nextRun.setDate(nextRun.getDate() + 1);
    }

    schedulerState.xsmb.nextRun = nextRun;

    // Cron job cho XSMB - ch·∫°y l√∫c 18h14
    const cronJob = cron.schedule(XSMB_CONFIG.schedule, async () => {
        if (schedulerState.xsmb.isRunning) {
            console.log('‚ö†Ô∏è XSMB Scheduler ƒëang ch·∫°y, b·ªè qua l·∫ßn n√†y');
            return;
        }

        schedulerState.xsmb.isRunning = true;
        schedulerState.xsmb.lastRun = new Date();

        try {
            const vietnamTime = getVietnamTime();
            const today = formatDate(vietnamTime);

            console.log(`üïê ${vietnamTime.toLocaleTimeString('vi-VN')} - B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu XSMB cho ng√†y ${today}`);

            // B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu v·ªõi worker thread
            const success = await scrapeWithRetry(today, XSMB_CONFIG.station, XSMB_CONFIG.retryAttempts, 'xsmb');

            if (success) {
                console.log(`‚úÖ Ho√†n th√†nh c√†o d·ªØ li·ªáu XSMB cho ng√†y ${today}`);

                // T·ª± ƒë·ªông d·ª´ng sau 20 ph√∫t (18h34)
                setTimeout(() => {
                    console.log(`üõë D·ª´ng c√†o d·ªØ li·ªáu XSMB l√∫c ${getVietnamTime().toLocaleTimeString('vi-VN')}`);
                }, XSMB_CONFIG.duration);

            } else {
                console.error(`üí• Th·∫•t b·∫°i c√†o d·ªØ li·ªáu XSMB cho ng√†y ${today} sau ${XSMB_CONFIG.retryAttempts} l·∫ßn th·ª≠`);
            }

        } catch (error) {
            console.error('üí• L·ªói kh√¥ng mong mu·ªën trong XSMB scheduler:', error);
            schedulerState.xsmb.totalErrors++;
        } finally {
            schedulerState.xsmb.isRunning = false;

            // T√≠nh to√°n th·ªùi gian ch·∫°y ti·∫øp theo
            const nextRun = new Date();
            nextRun.setDate(nextRun.getDate() + 1);
            nextRun.setHours(18, 14, 0, 0);
            schedulerState.xsmb.nextRun = nextRun;
        }
    }, {
        timezone: process.env.TIMEZONE || 'Asia/Ho_Chi_Minh',
        scheduled: true
    });

    console.log('‚úÖ XSMB Scraper Scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông th√†nh c√¥ng (v·ªõi worker threads)');

    // Return cron job ƒë·ªÉ c√≥ th·ªÉ d·ª´ng sau n√†y
    return cronJob;
};

// H√†m ch√≠nh ƒë·ªÉ kh·ªüi ƒë·ªông scheduler cho XSMT
const startXSMTScraperScheduler = () => {
    console.log('üöÄ Kh·ªüi ƒë·ªông XSMT Scraper Scheduler (v·ªõi worker threads)...');
    console.log(`üìÖ L·ªãch ch·∫°y: ${XSMT_CONFIG.schedule} (17h14 m·ªói ng√†y)`);
    console.log(`‚è±Ô∏è Th·ªùi gian ch·∫°y: ${XSMT_CONFIG.duration / 60000} ph√∫t`);
    console.log(`üîÑ Retry attempts: ${XSMT_CONFIG.retryAttempts}`);
    console.log(`‚è≥ Retry delay: ${XSMT_CONFIG.retryDelay / 1000} gi√¢y`);
    console.log(`üåç Timezone: ${process.env.TIMEZONE || 'Asia/Ho_Chi_Minh'}`);
    console.log(`‚ö° Worker threads: Enabled`);

    // T√≠nh to√°n th·ªùi gian ch·∫°y ti·∫øp theo
    const now = getVietnamTime();
    const nextRun = new Date(now);
    nextRun.setHours(17, 14, 0, 0);

    if (now > nextRun) {
        nextRun.setDate(nextRun.getDate() + 1);
    }

    schedulerState.xsmt.nextRun = nextRun;

    // Cron job cho XSMT - ch·∫°y l√∫c 17h14
    const cronJob = cron.schedule(XSMT_CONFIG.schedule, async () => {
        if (schedulerState.xsmt.isRunning) {
            console.log('‚ö†Ô∏è XSMT Scheduler ƒëang ch·∫°y, b·ªè qua l·∫ßn n√†y');
            return;
        }

        schedulerState.xsmt.isRunning = true;
        schedulerState.xsmt.lastRun = new Date();

        try {
            const vietnamTime = getVietnamTime();
            const today = formatDate(vietnamTime);

            console.log(`üïê ${vietnamTime.toLocaleTimeString('vi-VN')} - B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu XSMT cho ng√†y ${today}`);

            // B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu v·ªõi worker thread
            const success = await scrapeWithRetry(today, XSMT_CONFIG.station, XSMT_CONFIG.retryAttempts, 'xsmt');

            if (success) {
                console.log(`‚úÖ Ho√†n th√†nh c√†o d·ªØ li·ªáu XSMT cho ng√†y ${today}`);

                // T·ª± ƒë·ªông d·ª´ng sau 20 ph√∫t (17h34)
                setTimeout(() => {
                    console.log(`üõë D·ª´ng c√†o d·ªØ li·ªáu XSMT l√∫c ${getVietnamTime().toLocaleTimeString('vi-VN')}`);
                }, XSMT_CONFIG.duration);

            } else {
                console.error(`üí• Th·∫•t b·∫°i c√†o d·ªØ li·ªáu XSMT cho ng√†y ${today} sau ${XSMT_CONFIG.retryAttempts} l·∫ßn th·ª≠`);
            }

        } catch (error) {
            console.error('üí• L·ªói kh√¥ng mong mu·ªën trong XSMT scheduler:', error);
            schedulerState.xsmt.totalErrors++;
        } finally {
            schedulerState.xsmt.isRunning = false;

            // T√≠nh to√°n th·ªùi gian ch·∫°y ti·∫øp theo
            const nextRun = new Date();
            nextRun.setDate(nextRun.getDate() + 1);
            nextRun.setHours(17, 14, 0, 0);
            schedulerState.xsmt.nextRun = nextRun;
        }
    }, {
        timezone: process.env.TIMEZONE || 'Asia/Ho_Chi_Minh',
        scheduled: true
    });

    console.log('‚úÖ XSMT Scraper Scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông th√†nh c√¥ng (v·ªõi worker threads)');

    // Return cron job ƒë·ªÉ c√≥ th·ªÉ d·ª´ng sau n√†y
    return cronJob;
};

// H√†m ch√≠nh ƒë·ªÉ kh·ªüi ƒë·ªông scheduler cho XSMN
const startXSMNScraperScheduler = () => {
    console.log('üöÄ Kh·ªüi ƒë·ªông XSMN Scraper Scheduler (v·ªõi worker threads)...');
    console.log(`üìÖ L·ªãch ch·∫°y: ${XSMN_CONFIG.schedule} (16h12 m·ªói ng√†y)`);
    console.log(`‚è±Ô∏è Th·ªùi gian ch·∫°y: ${XSMN_CONFIG.duration / 60000} ph√∫t`);
    console.log(`üîÑ Retry attempts: ${XSMN_CONFIG.retryAttempts}`);
    console.log(`‚è≥ Retry delay: ${XSMN_CONFIG.retryDelay / 1000} gi√¢y`);
    console.log(`üåç Timezone: ${process.env.TIMEZONE || 'Asia/Ho_Chi_Minh'}`);
    console.log(`‚ö° Worker threads: Enabled`);

    // T√≠nh to√°n th·ªùi gian ch·∫°y ti·∫øp theo
    const now = getVietnamTime();
    const nextRun = new Date(now);
    nextRun.setHours(16, 24, 0, 0);

    if (now > nextRun) {
        nextRun.setDate(nextRun.getDate() + 1);
    }

    schedulerState.xsmn.nextRun = nextRun;

    // Cron job cho XSMN - ch·∫°y l√∫c 16h12
    const cronJob = cron.schedule(XSMN_CONFIG.schedule, async () => {
        if (schedulerState.xsmn.isRunning) {
            console.log('‚ö†Ô∏è XSMN Scheduler ƒëang ch·∫°y, b·ªè qua l·∫ßn n√†y');
            return;
        }

        schedulerState.xsmn.isRunning = true;
        schedulerState.xsmn.lastRun = new Date();

        try {
            const vietnamTime = getVietnamTime();
            const today = formatDate(vietnamTime);

            console.log(`üïê ${vietnamTime.toLocaleTimeString('vi-VN')} - B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu XSMN cho ng√†y ${today}`);

            // B·∫Øt ƒë·∫ßu c√†o d·ªØ li·ªáu v·ªõi worker thread
            const success = await scrapeWithRetry(today, XSMN_CONFIG.station, XSMN_CONFIG.retryAttempts, 'xsmn');

            if (success) {
                console.log(`‚úÖ Ho√†n th√†nh c√†o d·ªØ li·ªáu XSMN cho ng√†y ${today}`);

                // T·ª± ƒë·ªông d·ª´ng sau 30 ph√∫t (16h42)
                setTimeout(() => {
                    console.log(`üõë D·ª´ng c√†o d·ªØ li·ªáu XSMN l√∫c ${getVietnamTime().toLocaleTimeString('vi-VN')}`);
                }, XSMN_CONFIG.duration);

            } else {
                console.error(`üí• Th·∫•t b·∫°i c√†o d·ªØ li·ªáu XSMN cho ng√†y ${today} sau ${XSMN_CONFIG.retryAttempts} l·∫ßn th·ª≠`);
            }

        } catch (error) {
            console.error('üí• L·ªói kh√¥ng mong mu·ªën trong XSMN scheduler:', error);
            schedulerState.xsmn.totalErrors++;
        } finally {
            schedulerState.xsmn.isRunning = false;

            // T√≠nh to√°n th·ªùi gian ch·∫°y ti·∫øp theo
            const nextRun = new Date();
            nextRun.setDate(nextRun.getDate() + 1);
            nextRun.setHours(16, 24, 0, 0);
            schedulerState.xsmn.nextRun = nextRun;
        }
    }, {
        timezone: process.env.TIMEZONE || 'Asia/Ho_Chi_Minh',
        scheduled: true
    });

    console.log('‚úÖ XSMN Scraper Scheduler ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông th√†nh c√¥ng (v·ªõi worker threads)');

    // Return cron job ƒë·ªÉ c√≥ th·ªÉ d·ª´ng sau n√†y
    return cronJob;
};

// H√†m ƒë·ªÉ d·ª´ng scheduler
const stopScraperScheduler = () => {
    console.log('üõë D·ª´ng XSMB, XSMT & XSMN Scraper Scheduler...');
    schedulerState.xsmb.isRunning = false;
    schedulerState.xsmt.isRunning = false;
    schedulerState.xsmn.isRunning = false;
    // Cron s·∫Ω t·ª± ƒë·ªông d·ª´ng khi process k·∫øt th√∫c
};

// H√†m ƒë·ªÉ test scheduler ngay l·∫≠p t·ª©c
const testScraper = async (scraperType = 'xsmb') => {
    const vietnamTime = getVietnamTime();
    const today = formatDate(vietnamTime);

    console.log(`üß™ Test c√†o d·ªØ li·ªáu ${scraperType.toUpperCase()} cho ng√†y ${today} (v·ªõi worker thread)`);
    const success = await scrapeWithRetry(today, scraperType === 'xsmt' ? XSMT_CONFIG.station : scraperType === 'xsmn' ? XSMN_CONFIG.station : XSMB_CONFIG.station, 1, scraperType);

    if (success) {
        console.log(`‚úÖ Test c√†o d·ªØ li·ªáu ${scraperType.toUpperCase()} th√†nh c√¥ng`);
    } else {
        console.error(`‚ùå Test c√†o d·ªØ li·ªáu ${scraperType.toUpperCase()} th·∫•t b·∫°i`);
    }

    return success;
};

// H√†m ƒë·ªÉ l·∫•y tr·∫°ng th√°i scheduler
const getSchedulerStatus = () => {
    return {
        xsmb: {
            ...schedulerState.xsmb,
            config: XSMB_CONFIG,
            isActive: true,
            timezone: process.env.TIMEZONE || 'Asia/Ho_Chi_Minh'
        },
        xsmt: {
            ...schedulerState.xsmt,
            config: XSMT_CONFIG,
            isActive: true,
            timezone: process.env.TIMEZONE || 'Asia/Ho_Chi_Minh'
        },
        xsmn: {
            ...schedulerState.xsmn,
            config: XSMN_CONFIG,
            isActive: true,
            timezone: process.env.TIMEZONE || 'Asia/Ho_Chi_Minh'
        },
        environment: {
            nodeEnv: process.env.NODE_ENV,
            timezone: process.env.TIMEZONE,
            schedule: process.env.SCRAPE_SCHEDULE,
            scheduleMT: process.env.SCRAPE_SCHEDULE_MT,
            scheduleMN: process.env.SCRAPE_SCHEDULE_MN
        },
        performance: {
            workerThreads: true,
            memoryUsage: process.memoryUsage(),
            uptime: process.uptime()
        }
    };
};

module.exports = {
    startScraperScheduler,
    startXSMTScraperScheduler,
    startXSMNScraperScheduler,
    stopScraperScheduler,
    testScraper,
    getSchedulerStatus,
    XSMB_CONFIG,
    XSMT_CONFIG,
    XSMN_CONFIG
};